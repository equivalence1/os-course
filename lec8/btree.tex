\begin{frame}
\frametitle{Индексные структуры данных}
\begin{itemize}
  \item<1-> ФС отображает различные ключи на значения (возможно пустые):
    \begin{itemize}
      \item имя файла и inode родительского каталога на inode файла;
      \item inode файла/каталога и смещение на смещение на диске;
      \item поддерживает множество свободных блоков диска;
    \end{itemize}
  \item<2-> Все что нам нужно - правильная индексная структура данных:
    \begin{itemize}
      \item предназначенная для работы с диском;
      \item по возможности защищенная от ошибок;
      \item по возможности concurrent-friendly;
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{B-деревья}
\begin{itemize}
  \item<1-> B-деревья - сильно ветвистые идеально сбалансированные деревья поиска;
    \begin{itemize}
      \item каждый узел (кроме возможно корня) хранит от $B$ до $2 \times B$ ключей, где $B$ параметр дерева;
      \item $B$ обычно определяется размером ключа и размером блока ФС;
    \end{itemize}
  \item<2-> На практике чаще используются B+-деревья:
    \begin{itemize}
      \item внутренние узлы хранят только ключи и указатели на узлы;
      \item значения хранятся только в листьях;
      \item листья дерева могут быть связаны в список;
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Синхронизация B-деревьев}
\begin{itemize}
  \item<1-> У всех деревьев поиска (включая B-дереьвя) есть он \onslide<2->{- корень:}
    \onslide<3->{\begin{itemize}
      \item все операции начинаются от корня, как поиск, так и вставка и удаление;
      \item даже если корень меняется редко, вам все равно нужна синхронизация в корне;
      \item деревья поиска - очень не concurrent-friendly;
    \end{itemize}}
  \item<4-> Леман и Яо предложили довольно эффективную схему синхронизации B-деревьев:
    \begin{itemize}
      \item читателям не требуется никакая синхронизация (в модели оригинальной статьи);
      \item писатели в каждый момент времени держат константное количество блокировок;
      \item оригинальная статья: Efficient Locking for Concurrent Operations on B-Trees
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Синхронизация B-деревьев}
\begin{itemize}
  \item<1-> Нам потребуется изменить структуру B-дерева немного:
    \begin{itemize}
      \item все узлы хранят ссылку на следующий узел того же уровня;
      \item после разделения узел и сосед работают "как один" узел благодаря ссылке;
      \item почти на все узлы есть две ссылки: ссылка из родителя и ссылка из соседа;
      \item ссылка из соседа на новый узел всегда устанавливается первой, а затем мы будем изменять родителя;
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Синхронизация B-деревьев}
\begin{itemize}
  \item Поиск ключа в дереве:
    \begin{itemize}
      \item мы выполняем обычный поиск по дереву поиска, до тех пор пока не найдем нужную пару ключ/значение;
      \item во время поиска мы могли прийти в узел, максимальный ключ которого меньше искомого;
        \begin{itemize}
          \item это могло произойти в результате разделения узла (не успели обновить родителя);
          \item просто воспользуемся ссылкой на соседа и заглянем в соседний узел;
        \end{itemize}
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Синхронизация B-деревьев}
\begin{itemize}
  \item Вставка узла в дерево:
    \begin{itemize}
      \item Начинаем с поиска позиции для вставки
        \begin{itemize}
          \item после того как мы нашли нужный лист и перед тем как мы его запишем кто-то может его обновить;
          \item поэтому нужно захватить блокировку на узле и двигаться по правым ссылкам уже с блокировками;
        \end{itemize}
      \item Мы нашли и заблокировали нужный узел - теперь нужно вставить ключ
        \begin{itemize}
          \item вставка может потребовать разделения - сначала нужно записать правый узел;
          \item потом нужно записать левый узел с правильной ссылкой на соседа;
        \end{itemize}
      \item После разделения нужно обновить родителя, а для этого нужно его найти
        \begin{itemize}
          \item опять же проходом по правым ссылкам;
        \end{itemize}
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{LSM дерево}
\begin{itemize}
  \item<1-> Обычные B-деревья (и их вариации) обладают рядом недостатков:
    \begin{itemize}
      \item расположение на диске - узлы дерева разбросаны как попало;
      \item concurrent-unfriendliness - требуются нетривиальные схемы синхронизации, вступающие в противоречия с другими требованиями;
    \end{itemize}
  \item<2-> Проблемы B-деревьев возникают из-за удаления и вставки:
    \begin{itemize}
      \item без операций вставки и удаления деревья становятся очень простыми (очень пустыми);
      \item мы можем заменить операции вставки и удаления операцией слияния;
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{LSM дерево}
\begin{itemize}
  \item<1-> LSM (Log-Structured Merge) дерево состоит из нескольких деревьев:
    \begin{itemize}
      \item $C_0$ - дерево в памяти, единственное дерево в которое можно вставлять или удалять;
      \item $C_1$ - $C_k$ - набор неизменяемых деревьев на диске (например, B+-деревьев);
    \end{itemize}
  \item<2-> Операция слияния сливает два соседних дерева в одно новое:
    \begin{itemize}
      \item в результате слияния $C_1$ и $C_2$ получим два дерева: $C'_1$ - пустое, и $C'_2$ - дерево объединения;
      \item слияние - просто проход по двум упорядоченным деревьям с выписыванием значений;
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{LSM дерево}
\begin{itemize}
  \item<1-> Для удаления ключа из LSM дерева используем вставку и слияние:
    \begin{itemize}
      \item вставьте ключ со специальным маркером означающем удаленный узел;
      \item при слиянии деревьев удаляйте отбрасывайте этот ключ в старых деревьях;
      \item при слиянии в последнее дерево, просто отбросим ключ с маркером;
    \end{itemize}
  \item<2-> Непосредственные модификации происходят только над $C_0$, который находится в памяти
    \begin{itemize}
      \item слияние, очевидно, не требует модификации, т. е. все деревья на диске неизменны;
      \item после объединения деревьев нужно просто поправить указатель на корень;
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{LSM дерево}
\begin{itemize}
  \item<1-> Ключевой вопрос - когда нужно выполнять слияние?
    \begin{itemize}
      \item обычно, слияние определяется размером дерева - сливаем дерево со следующим, если оно стало большим;
      \item соответственно, размеры деревьев растут с индексом дерева;
    \end{itemize}
  \item<2-> Какими должны быть размеры деревьев?
    \begin{itemize}
      \item если размеры деревьев образуют геометрическую прогрессию вы получите амортизировано $O(1)$ на слияние (!!! это не правда, каждый вставленный ключ проходит $(k-1) * q$ слияний до тех пор пока он не попадет в $k$-ое дерево);
      \item количество деревьев, обычно, фиксировано, а последнее дерево растет неограниченно;
    \end{itemize}
\end{itemize}
\end{frame}
