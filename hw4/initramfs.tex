\section{Initramfs}

Initramfs (Initial RAM FS) - начальная файловая система в памяти. Обычно она
используется только при старте ОС, чтобы ОС могла найти на ней исполняемый
файл первого приложения (init) и утилиты нужные для конфигурации системы.

В нашем случае начальная файловая система так же будет и единственной, т. е.
другой файловой системы кроме этой у нас не будет.

Стоит отметить, что не все системы используют initramfs, некоторые системы
могут сразу читать данные с диска. Но мы не будем так делать, потому что
реализация файловой системы в памяти гораздо проще.

\subsection{Формат CPIO}

Итак откуда начальная файловая система берет свое содержимое? Обычно
содержимое запаковано в некоторый архив\footnote{Не для сжатия, а для того
чтобы был один файл.} в специальном формате, который загружается в память
системы вместе с ядром ОС. О том куда именно он загружается мы поговорим дальше,
сейчас мы сосредоточимся на формате архива.

Вам в домашнем задании предлагается использовать бывший некогда популярным
формат cpio\footnote{cpio - аналог tar, но имеет несколько более простое
внутреннее представление.}. Формат cpio очень прост:
\begin{itemize}
  \item каждая сущность (файл/каталог) в архиве начинается со специального
        заголовка фиксированного формата;
  \item каждый заголовок выровнен на границу 4 байт, т. е. если размер
        описания предыдущей сущности не был кратен 4 (заголовок + имя + данные
        файла), то вы должны сами выровнять текущую позицию от начала архива;
  \item сразу за заголовком идет имя файла/каталога переменной длинны (размер
        имени есть в заголовке);
  \item далее, выровненными на границу 4 байт, идут данные файла, если заголовок
        описывал файл (размер данных опять же в заголовке); обратите внимание,
        что даже если длина имени не кратна 4 байтам, позиция данных файла все
        равно должна быть выровнена на границу 4 байт - ваша обязанность следить
        за этим при чтении;
\end{itemize}

Конец архива определяется либо когда вы не смогли прочитать сущность из архива
целиком, либо когда в наткнулись на сущность с именем "TRAILER!!!"\footnote{Ппц...}.

Чтобы сделать вашу жизнь еще "проще", все данные в заголовке записаны в текстовом
представлении в 16-ти ричном формате\footnote{Без всяких префиксов, наиболее
значимые цифры по меньшим индексам массива - детали легко определяются
экспериментально}. Формат заголовка вы можете найти в файле initramfs.h.

Гарантируется, что каталоги встретятся в cpio архиве раньше, чем файлы в этих
каталогах, если каталоги не пустые. Т. е. просматривая архив по порядку вы
всегда сначала создадите каталог, а уже потом будете добавлять в него файлы.

Для того чтобы распарсить этот формат остается одна маленькая деталь - нужно
уметь отличать каталоги от файлов - для этого в initramfs.h определены макросы:

\begin{itemize}
  \item S\_ISDIR - проверяет, что число записанное в поле mode заголовка
        соответствует каталогу;
  \item S\_ISREG - проверяет, что число записанное в поле mode заголовка
        соответствует обычному файлу\footnote{"Необычные" файлы нас не интересуют.}.
\end{itemize}

\subsection{Создание образа initramfs}

Для создания образа initramfs вам предоставлен bash скрипт make\_initramfs.sh.
Как первый аргумент он принимает имя каталога, который нужно запаковать в
initramfs\footnote{Учтите, что это имя будет частью имени сущности в архиве.}.
Вторым параметром скрипт получает имя выходного файла, в который он запишет
этот образ. Для создание образа используется утилита cpio.

\subsection{Передача образа initramfs}

Теперь нам нужно каким-то образом передать этот образ в QEMU, чтобы он был
загружен вместе с ядром ОС. А кроме того внутри ядра ОС каким-то образом узнать
куда этот образ будет загружен.

Первая часть решается легко. У QEMU есть опция -initrd, после которой нужно
указать имя файла.

Со второй частью все несколько сложнее. Так как наше ядро пользуется спецификацией
multiboot разумно искать в ней указания на то, где нужно искать образ initramfs.
Но, к сожалению, в спецификации multiboot нет ничего подобного.

Но в multiboot есть такая вещь как загружаемые модули. Собтственно QEMU передает
образ initramfs под видом одного из этих модулей. За модули в заголовке multiboot
отвечают поля mods\_count и mods\_addr. Но перед тем как обращаться к ним, нужно
убедиться, что они содержат валидную информацию. Для этого нужно проверить
установлен ли 3-ий бит\footnote{Считая с 0.} в поле flags заголовка multiboot.

Если информация в этих полях валидна, то mods\_addr содержит адрес массива
дескрипторов описывающих модули. Конкретный формат дескриптора уточняйте в
документации multiboot.

Как найти среди этих модулей тот, что нужен нам? Это довольно легко, если мы
знаем где располагается модуль в памяти. Как известно initramfs образ будет
начинаться с заголовка cpio. Первое поле в каждом заголовке cpio это магическое
значение. Т. е. все что нам нужно, так это проверить, что размер модуля достаточно
большой и что он начинается с некоторой магической последовательности байт, а
именно "070701".

Остается один небольшой момент, как и с ядром ОС вы должны указать вашим
алокаторам памяти, чтобы они не могли алоцировать образ initramfs до тех пор
пока вы не прочитали его.
