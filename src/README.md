#Cover letter

Я взял за основу код из `sol/`, т.к. в моём прошлом дз я не сделал `printf`, а тут без него никак, надо выводить карту памяти.
Насколько я понял, так делать можно (брать код из `sol/`). Собственно, помимо того, что там уже было, добавилось следующее.

##common.h
Тут просто собраны какие-то мини-функции, которыми я часто пользуюсь, или которые некуда особо было отнести логически, а отдельный файл для одной функции
создавать не хотелось

##test.c
Просто вынес туда какой-то свой дебаг

##multiboot\_structs.h
Тут описаны структуры, которые нам дал bootloader и которыми мы пользуемся. Их только три:
* `struct multiboot_info` --- собственно сама структура, которую нам передает bootloader
* `struct multiboot_mmap_entry` --- эта структура описывает содержимое структуры `mmap`, которую нам передает bootloader
* `struct mmap` --- это просто структура для нашей копии `mmap`'a, переданного bootloader'ом. В эту копию я и запишу нашу ОС.

##memmap.c
* `multiboot_info_t *mbt` --- указатель на саму структуру multiboot\_info, переданную bootloader'ом
* `mmap_t os_mmap` --- это и есть наша карта памяти. В неё мы просто копируем то, что передал bootloader и плюс к этому добавляем информацию о нашем ядре
* `set_mbt()` --- просто выставляем `mbt`
* `mmap_check_presented()` --- проверяем, что bootloader действительно передал нам карту памяти
* `make_os_mmap_entry()` --- создаем информацию о нашем ядре для `os_mmap`
* `mmap_reserve_os()` --- добавляем эту запись в `os_mmap`
* `is_free(*segment)` --- проверяет, что этот сегмент памяти можно использовать (т.е. он не пересекается с зарезервированными и полностью лежит в каком-то свободном)
* `get_memory_range()` --- возвращает сегмент, соответствующий всей нашей физической памяти
* `get_map()` --- считываем и копируем `mmap`, который предоставил bootloader и нашу копию (`os_mmap`)
* `print_mmap_entry()` --- функция для печати этих структур (выводится все в `serial`, т.к. туда пишет `printf`)

##buddy.c
* `get_number_in_level()` --- номер дескритора страницы в соотв. уровне
* `get_my_buddy()` --- возвращает дескритор (первый дескритор в отрезке дескриторов, если быть точным), который является buddy данного
* `can_merge()` --- проверяем, что можем смержить два отрезка дескрипторов в один большой
* `merge()` --- мержим
* `split()` --- разбиваем отрезок дескриторов на 2
* `init_buddy_descriptors()` --- если отрезок `is_free`, то пихаем это дескритор на 0-й уровень и ставим статус NODE\_FREE
* `build_lists()` --- теперь пока можем все мержим
* `buddy_allocate(size)` --- аллоцируем сколько сказали памяти. Возвращаем указатель готовый к работе
* `buddy_free(ptr)` --- ну понятно

##boot\_allocator.c
* `boot_reserv_memory(size)` --- ну тоже понятно

##paging.c
* `make_new_paging()` --- cтроим наш новый paging
* `create_paging(va_start, pa_start, len)` --- создаем пэйджинг, который ставит в соответствие отрезок виртуальной памяти `[va_start, va_start + len)` отрезок физической памяти `[pa_start, pa_start + len)`
* `create_pml4()` --- аллоцирует таблицу `PML4E`

