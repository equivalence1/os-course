#COVER LETTER

##main.c
тут добавился вызов двух функций, о которых я дальше напишу

* `setup_threads`

* `test_threads`

##entry.S
* `switch_threads` -- просто меняет контекст.

##scheduler.c
* `schedule` -- сам планировщик. Он берет текущий поток, берет следующий и меняет контекст посредством вызова `switch_threads`.
Контракт для этого метода -- он должен запускаться с отключенными прерываниями, иначе там есть одно тонкое место (я указал в комментарии).
Поэтому в прерывании pit'a мы просто вызываем `schedule`, а если поток сам хочет, чтобы его заменили, то ему стоит вызывать `yield`.

* `yield` -- вызывает `schedule`, предворительно отключая прерывания, затем снова включая.

* `join` -- принимает `pid` и ждёт, пока тот не завершится.

##thread.h
* `init` -- это наш главный поток, который жив пока жива система. В некотором смысле аналог `init` в Linux. (по модулю `wait(NULL`)

* `current_thread` -- просто указатель на текущий поток (исполняющийся) в очереди потоков.

##thread.c

* `thread_exit` -- это аналог `exit` в Linux. Просто удаляет поток из очереди, освобождает память из под него и ставит исполнятся след. поток.
Замечу, что мы можем тут сначала освободить память потока, а потом что-то делать с ним в `schedule` (брать `pid` и `rsp`), т.к. я отключаю прерывания,
а ничего не аллоцирую, а slab-аллокатор никак не портит эту память.

* `main_function_wrapper` -- просто запускает поток, предварительно включая прерывания, а потом, когда тот завершит исполнение своего `main`'a, просто удаляет
его, вызывая `thread_exit`

* `make_rflags` -- я по дефолту ставлю `%rflags` потоку. Он будет равен `%rflags` текущего потока, кроме статусных флагов. Их я сбрасываю в 0.

* `setup_stack` -- инициализирует стек потока, чтобы потом контест был нормально сменен в `switch_threads`. 
Выставлять регистры r12-r15, rbx не обязательно. Я просто ставлю в 0, чтобы быть аккуратным. Там же на стек кладу `%rflags` и адрес возврата (это адрес
`main_function_wrapper`.

* `create_thread` -- аллоцирует место под дескритор потока, выставляет ему поля, вызывает `setup_stack`, добавляет поток в очередь

* `setup_threas` -- тут я просто инициализирую `init`. Стэк я ему тут никак не настраиваю. Это будет сделано при первой смене потока автоматически в `switch_treads`.

* `pid_in_list` -- это нужно для `join`. Просто проходится по списку поток и ищет, есть ли поток с таким `pid` в списке.

##locks.c
Тут просто `lock` и `unlock`. Я написал Ticket lock, как у нас на лекциях было.

##test.c
Тут просто тест. Я создаю потоки, к каким-то джойнюсь, потом ещё тест на локи.
